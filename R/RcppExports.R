# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Element-wise Soft Thresholding Function for Vector
#' @description Soft thresholding function for a vector which is the solution of the  
#' \deqn{\argmin_x ||y-x||_2^2/2+\lambda ||x||_1.}
#' @param \code{y} a vector
#' @param \code{lambda} a scalar
#' @return Vector after threholding
#' 
#' @export
#'
soft_vec <- function(y, lambda) {
    .Call(`_HiQR_soft_vec`, y, lambda)
}

#' @title Element-wise Soft Thresholding Function for a Matrix
#' @description Soft thresholding function for Matrix which is the solution of the  
#' \deqn{\argmin_X ||X-A||_2^2/2+a ||X||_1.}
#' @param \code{A} Matrix
#' @param \code{a} scalar
#' @return Matrix after threholding
#' 
#' @export
#'
soft <- function(A, a) {
    .Call(`_HiQR_soft`, A, a)
}

#' @title Proximal projection of a Vector with  \eqn{\ell_\infty} penalty. 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_\infty.}
#' @param \code{x} a vector
#' @param \code{lambda} a scalar
#' @return A vector which is proximal projection solution.
#' 
#' @export
#'
inf_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_inf_vec`, x, lambda)
}

#' @title Proximal projection of a Matrix with  \eqn{\ell_\infty} penalty. 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_\infty.}
#' @param \code{X} a Matrix
#' @param \code{lambda} a scalar
#' @param \code{k} Not penalized the first \code{k} columns. Default is 1.
#' @return A Matrix.
#' 
#' @export
#'
inf_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_inf_mat`, X, lambda, k)
}

#' @title Proximal projection of a Vector with  \eqn{\ell_2} penalty (Group LASSO). 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_2.}
#' @param \code{x} a vector
#' @param \code{lambda} a scalar
#' @return A vector which is proximal projection solution.
#' 
#' @export
#'
l2_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_l2_vec`, x, lambda)
}

#' @title Proximal projection of a Matrix with  \eqn{\ell_2} penalty. 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_2.}
#' @param \code{X} a Matrix
#' @param \code{lambda} a scalar
#' @param \code{k} Not penalized the first \code{k} columns. Default is 1.
#' @return A Matrix.
#' 
#' @export
#'
l2_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_l2_mat`, X, lambda, k)
}

#' @title Proximal projection of a Vector with a hybrid \eqn{\ell_1/\ell_\infty} penalty. 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda  \max\{|y_1|, \sum_{i=2}^p |y_i|\}.}
#' @param \code{x} a vector
#' @param \code{lambda} a scalar
#' @return A vector which is proximal projection solution.
#' 
#' @export
#'
l1inf_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_l1inf_vec`, x, lambda)
}

#' @title Proximal projection of a Matrix with a hybrid \eqn{\ell_1/\ell_\infty} penalty. 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda  \max\{|y_1|, \sum_{i=2}^p |y_i|\}.}
#' @param \code{X} a Matrix
#' @param \code{lambda} a scalar
#' @param \code{k} Not penalized the first \code{k} columns. Default is 1.
#' @return A Matrix.
#' 
#' @export
#'
l1inf_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_l1inf_mat`, X, lambda, k)
}

#' @title Proximal projection of a Matrix with different penalties. 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda \cdot p(y).}
#' @param \code{X} a Matrix
#' @param \code{lambda} a scalar
#' @param \code{type} The penalty to use for the columns of matrix \code{X}.
#'  \eqn{1} is the \eqn{\ell_\infty} penalty; \eqn{2} is the \eqn{\ell_2} penalty (Group LASSO); \eqn{3} is the hybrid \eqn{\ell_1/\ell_\infty} penalty.
#' @param \code{k} Not penalized the first \code{k} columns. Default is 1.
#' @return A Matrix.
#' 
#' @export
#'
proc <- function(X, lambda = 0, type = 1L, k = 1L) {
    .Call(`_HiQR_proc`, X, lambda, type, k)
}

#' @title Weighted Gram Matrix
#' @description \code{gram} computes the weighted Gram matrix: 
#' \deqn{ X^\top diag(w) X.}
#' @param \code{X}  a \eqn{n \times p} Matrix
#' @param \code{w} a \eqn{n} dimensional weight vector
#' @return Weighted Gram Matrix
#' 
#' @export
gram <- function(X, w) {
    .Call(`_HiQR_gram`, X, w)
}

#' @title Quadratic of Each Row 
#' @description \code{qrow} computes the quadratic of Each Row : 
#' \deqn{ \diag(X W X^\top)=(X_1^\top W X_1,\cdots,X_n^\top W X_n)^\top}
#' @param \code{X}  a \eqn{n*p} Matrix
#' @param \code{W} a \eqn{p*p} weight Matrix
#' @return Quadratic of Each Row 
#' 
#' @export
qrow <- function(X, W) {
    .Call(`_HiQR_qrow`, X, W)
}

#' @title Quadratic regression with squared \eqn{\ell_2} penalty (Ridge regression)  
#' @description Algorithm for high dimensional Quadratic regression with squared \eqn{\ell_2} penalty
#' @param \code{X} a \eqn{n*p} input data matrix.
#' @param \code{Y} a \eqn{n} response vector.  
#' @param \code{lambda} user supplied tuning parameter; 
#' @return A list with components
#' \item{Omega}{a list of sparse p*p matrices corresponding to lambda.}
#' \item{lambda}{the used lambda.}
#' 
#' @export
#' 
ridge_qr <- function(X, Y, lambda) {
    .Call(`_HiQR_ridge_qr`, X, Y, lambda)
}

#' @title Quadratic regression with \eqn{\ell_1} penalty 
#' @description ADMM algorithm for high dimensional Quadratic regression with \eqn{\ell_1} penalty
#' @param \code{X} a \eqn{n*p} input data matrix.
#' @param \code{Y} a \eqn{n} response vector.  
#' @param \code{lambda}, user supplied tuning parameter; 
#' @param \code{err_abs}, \code{err_rel}   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, Maximum number of iterations. Default is 1000.
#' @param \code{rho}, initial step parameter for ADMM.
#' @return A list with components
#' \item{Omega}{a list of sparse p*p matrices corresponding to lambda.}
#' \item{lambda}{the used lambda for the solution path.}
#' \item{niter}{the number of iterations for each element of lambda.}
#' 
#' @export
#' 
qr1 <- function(X, Y, lambda, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 1) {
    .Call(`_HiQR_qr1`, X, Y, lambda, err_abs, err_rel, maxIter, rho)
}

#' @title Quadratic regression with \eqn{\ell_1} penalty and an additional penalty
#' @description ADMM algorithm for high dimensional Quadratic regression with \eqn{\ell_1} and other penalties.
#' @param \code{X}, a \eqn{n*p} input data matrix.
#' @param \code{Y}, a \eqn{n} response vector.  
#' @param \code{lambda}, user supplied tuning parameter; 
#' @param \code{type} The additional penalty to use for the quadratic regression.
#'  \eqn{1} is the \eqn{\ell_\infty} penalty; \eqn{2} is the \eqn{\ell_2} penalty (Group LASSO); \eqn{3} is the hybrid \eqn{\ell_1/\ell_\infty} penalty.
#' @param \code{err_abs}, \code{err_rel}   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, maximum number of iterations. Default is 200.
#' @param \code{rho}, initial step parameter for ADMM.
#' 
#' @return A list with components
#' \item{Omega}{a list of sparse p*p matrices corresponding to lambda.}
#' \item{lambda}{the used lambda for the solution path.}
#' \item{niter}{the number of iterations for each element of lambda.}
#' @export
#' 
qr2 <- function(X, Y, lambda1, lambda2, type = 1L, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 5) {
    .Call(`_HiQR_qr2`, X, Y, lambda1, lambda2, type, err_abs, err_rel, maxIter, rho)
}

