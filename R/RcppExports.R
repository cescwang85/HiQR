# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Element-wise soft-thresholding function for a vector
#' @description Soft-thresholding function for a vector which is the solution of
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_1.}
#' @param \code{x}, a vector.
#' @param \code{lambda}, a scalar.
#' @return a vector after threholding.
#' 
#' @export
#'
soft_vec <- function(x, lambda) {
    .Call(`_HiQR_soft_vec`, x, lambda)
}

#' @title Element-wise soft-thresholding function for a matrix
#' @description Soft-thresholding function for a matrix which is the solution of
#' \deqn{\argmin_Y ||Y-X||_2^2/2+\lambda ||Y||_1.}
#' @param \code{X}, a matrix.
#' @param \code{lambda}, scalar.
#' @param  \code{k}, Not penalized the first element. Default is \code{1}(TRUE).
#' 
#' @return a matrix after threholding.
#' 
#' @export
#'
soft <- function(X, lambda, k = 1L) {
    .Call(`_HiQR_soft`, X, lambda, k)
}

#' @title Proximal projection of a \eqn{\ell_\infty} penalty. 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_\infty.}
#' @param \code{x}, a vector.
#' @param \code{lambda}, a scalar.
#' @return a vector after proximal projection.
#' 
#' @export
#'
inf_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_inf_vec`, x, lambda)
}

#' @title Proximal projection of a \eqn{\ell_\infty} penalty for a matrix 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_\infty.}
#' @param \code{X}, a Matrix.
#' @param \code{lambda}, a scalar.
#' @param \code{k}, Not penalized the first \code{k} columns. Default is 1.
#' @return a matrix.
#' 
#' @export
#'
inf_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_inf_mat`, X, lambda, k)
}

#' @title Proximal projection of a \eqn{\ell_2} penalty (Group LASSO). 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_2.}
#' @param \code{x}, a vector.
#' @param \code{lambda}, a scalar.
#' @return a vector.
#' 
#' @export
#'
l2_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_l2_vec`, x, lambda)
}

#' @title Proximal projection of a \eqn{\ell_2} penalty for a matrix 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda ||y||_2.}
#' @param \code{X}, a Matrix.
#' @param \code{lambda}, a scalar.
#' @param \code{k}, Not penalized the first \code{k} columns. Default is 1.
#' @return A Matrix.
#' 
#' @export
#'
l2_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_l2_mat`, X, lambda, k)
}

#' @title Proximal projection of a hybrid \eqn{\ell_1/\ell_\infty} penalty for a vector 
#' @description Proximal projection solution of a vector which is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda  \max\{|y_1|, \sum_{i=2}^p |y_i|\}.}
#' @param \code{x}, a vector.
#' @param \code{lambda}, a scalar.
#' @return a vector.
#' 
#' @export
#'
l1inf_vec <- function(x, lambda = 0) {
    .Call(`_HiQR_l1inf_vec`, x, lambda)
}

#' @title Proximal projection of a hybrid \eqn{\ell_1/\ell_\infty} penalty for a matrix 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda  \max\{|y_1|, \sum_{i=2}^p |y_i|\}.}
#' @param \code{X}, a matrix.
#' @param \code{lambda}, a scalar.
#' @param \code{k}, Not penalized the first \code{k} columns. Default is 1.
#' @return a matrix.
#' 
#' @export
#'
l1inf_mat <- function(X, lambda = 0, k = 1L) {
    .Call(`_HiQR_l1inf_mat`, X, lambda, k)
}

#' @title Proximal projection of a nuclear norm penalty.
#' @description Proximal projection solution of a matrix with a nuclear norm penalty: 
#' \deqn{\argmin_Y ||Y-X||_2^2/2+\lambda \|Y\|_*.}
#' @param \code{X}, a matrix.
#' @param \code{lambda}, a scalar.
#' @return a matrix.
#' 
#' @export
#'
nuclear_mat <- function(X, lambda) {
    .Call(`_HiQR_nuclear_mat`, X, lambda)
}

#' @title Proximal projection of a Matrix with penalty. 
#' @description Proximal projection solution of a Matrix where each column is the solution:
#' \deqn{\argmin_y ||y-x||_2^2/2+\lambda \cdot p(y).}
#' or proximal projection of nuclear norm.
#' @param \code{X}, a matrix.
#' @param \code{lambda}, a scalar.
#' @param \code{type}, The penalty to use. \eqn{1} (Default) is the \eqn{\ell_1} penalty; 
#' \eqn{2} is the \eqn{\ell_\infty} penalty; \eqn{3} is the \eqn{\ell_2} penalty;
#'  \eqn{4} is the hybrid \eqn{\ell_1/\ell_\infty} penalty.
#' @param \code{k}, Not penalized the first element (for \eqn{\ell_1} penalty) or the first \code{k} columns (for other penalties). Default is 1.
#' Not work for the nuclear norm. 
#' @return a matrix.
#' 
#' @export
#'
proc <- function(X, lambda = 0, type = 1L, k = 1L) {
    .Call(`_HiQR_proc`, X, lambda, type, k)
}

#' @title Weighted Gram matrix
#' @description Calculate the weighted Gram matrix:\eqn{X^\top diag(w)X}.
#' @param \code{X},  a \eqn{n \times p} matrix.
#' @param \code{w}, a \eqn{n} dimensional weight vector.
#' @return a \eqn{p \times p} matrix.
#' 
#' @export
gram <- function(X, w) {
    .Call(`_HiQR_gram`, X, w)
}

#' @title Quadratic form for each sample 
#' @description Calculate the quadratic form for each sample with a Weight matrix \code{W}: 
#' \deqn{ diag(X W X^\top)=(X_1^\top W X_1,\cdots,X_n^\top W X_n)^\top.}
#' @param \code{X},  a \eqn{n \times p} matrix.
#' @param \code{W}, a \eqn{p \times p} weight matrix.
#' @return a \eqn{n} dimensional vector.
#' 
#' @export
qrow <- function(X, W) {
    .Call(`_HiQR_qrow`, X, W)
}

#' @title Quadratic regression with squared \eqn{\ell_2} penalty (Ridge regression)  
#' @description Algorithm for High dimensional Quadratic Regression(HiQR) with squared \eqn{\ell_2} penalty:
#' \deqn{\argmin_Y \frac{1}{2n}\sum_{i=1}^n (Y_i-X_i^\top \Omega X_i)^2+\lambda \|\Omega\|_2^2.}
#' @param \code{X}, a \eqn{n \times p} data matrix.
#' @param \code{Y}, a \eqn{n} dimensional response vector.  
#' @param \code{lambda}, user supplied tuning parameter; 
#' @return A list with components
#' \item{Omega}{a list of sparse \eqn{p \times p} matrices corresponding to lambda.}
#' \item{lambda}{the used lambda.}
#' 
#' @export
#' 
qr2 <- function(X, Y, lambda) {
    .Call(`_HiQR_qr2`, X, Y, lambda)
}

#' @title Quadratic regression with \eqn{\ell_1} penalty 
#' @description ADMM algorithm for high dimensional Quadratic regression with a \eqn{\ell_1} norm penalty:
#' \deqn{\argmin_Y \frac{1}{2n}\sum_{i=1}^n (Y_i-X_i^\top \Omega X_i)^2+\lambda \|\Omega\|_1.} 
#' @param \code{X}, a \eqn{n*p} input data matrix.
#' @param \code{Y}, a \eqn{n} response vector.  
#' @param \code{lambda}, user supplied tuning parameter.
#' @param \code{err_abs}, \code{err_rel}   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, Maximum number of iterations. Default is 1000.
#' @param \code{rho}, initial step parameter for ADMM.
#' @return A list with components
#' \item{Omega}{a list of sparse p*p matrices corresponding to lambda.}
#' \item{lambda}{the used lambda for the solution path.}
#' \item{niter}{the number of iterations for each element of lambda.}
#' 
#' @export
#' 
qr1 <- function(X, Y, lambda, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 1) {
    .Call(`_HiQR_qr1`, X, Y, lambda, err_abs, err_rel, maxIter, rho)
}

#' @title Quadratic regression with \eqn{\ell_1} penalty and an additional penalty
#' @description ADMM algorithm for high dimensional Quadratic regression with \eqn{\ell_1} and another penalty:
#' \deqn{\argmin_Y \frac{1}{2n}\sum_{i=1}^n (Y_i-X_i^\top \Omega X_i)^2+\lambda_1 \|\Omega\|_1+\lambda_2 p(\Omega)+\lambda_2 p(\Omega^\top).} 
#' @param \code{X}, a \eqn{n\times p} data matrix.
#' @param \code{Y}, a \eqn{n} dimensional response vector.  
#' @param \code{lambda1}, user supplied tuning parameters.
#' @param \code{lambda2}, user supplied tuning parameters.
#' @param \code{type} The additional penalty to use for the quadratic regression.
#'  \eqn{2} is the \eqn{\ell_\infty} penalty; \eqn{3} is the \eqn{\ell_2} penalty (Group LASSO); \eqn{4} is the hybrid \eqn{\ell_1/\ell_\infty} penalty.
#' @param \code{err_abs}, \code{err_rel},   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, maximum number of iterations. Default is 200.
#' @param \code{rho}, initial step parameter for ADMM.
#' 
#' @return A list with components
#' \item{Omega}{a list of sparse \eqn{p \times p} matrices corresponding to lambda.}
#' \item{lambda1}{the used lambda1 for the solution path.}
#' \item{lambda2}{the used lambda2 for the solution path.}
#' \item{niter}{the number of iterations for each element of (lambda1,lambda2).}
#' @export
#' 
qr3 <- function(X, Y, lambda1, lambda2, type = 2L, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 5) {
    .Call(`_HiQR_qr3`, X, Y, lambda1, lambda2, type, err_abs, err_rel, maxIter, rho)
}

#' @title Quadratic regression with nuclear norm penalty 
#' @description ADMM algorithm for high dimensional Quadratic regression with a \eqn{\ell_1} norm penalty:
#' \deqn{\argmin_Y \frac{1}{2n}\sum_{i=1}^n (Y_i-X_i^\top \Omega X_i)^2+\lambda \|\Omega\|_*.} 
#' @param \code{X}, a \eqn{n*p} input data matrix.
#' @param \code{Y}, a \eqn{n} response vector.  
#' @param \code{lambda}, user supplied tuning parameter; 
#' @param \code{err_abs}, \code{err_rel}   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, Maximum number of iterations. Default is 1000.
#' @param \code{rho}, initial step parameter for ADMM.
#' @return A list with components
#' \item{Omega}{a list of sparse p*p matrices corresponding to lambda.}
#' \item{lambda}{the used lambda for the solution path.}
#' \item{niter}{the number of iterations for each element of lambda.}
#' 
#' @export
#' 
qr1_rank <- function(X, Y, lambda, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 1) {
    .Call(`_HiQR_qr1_rank`, X, Y, lambda, err_abs, err_rel, maxIter, rho)
}

#' @title Quadratic regression with \eqn{\ell_1} penalty and nuclear norm penalty (Sparse and Low rank)
#' @description ADMM algorithm for high dimensional Quadratic regression with \eqn{\ell_1} and nuclear norm penalty:
#' \deqn{\argmin_Y \frac{1}{2n}\sum_{i=1}^n (Y_i-X_i^\top \Omega X_i)^2+\lambda_1 \|\Omega\|_1+\lambda_2 \|\Omega\|_*.} 
#' @param \code{X}, a \eqn{n\times p} data matrix.
#' @param \code{Y}, a \eqn{n} dimensional response vector.  
#' @param \code{lambda1}, user supplied tuning parameters.
#' @param \code{lambda2}, user supplied tuning parameters.
#' @param \code{err_abs}, \code{err_rel},   the precision used to stop the convergence of ADMM. 
#' @param \code{maxIter}, maximum number of iterations. Default is 200.
#' @param \code{rho}, initial step parameter for ADMM.
#' 
#' @return A list with components
#' \item{Omega}{a list of sparse \eqn{p \times p} matrices corresponding to lambda.}
#' \item{lambda1}{the used lambda1 for the solution path.}
#' \item{lambda2}{the used lambda2 for the solution path.}
#' \item{niter}{the number of iterations for each element of (lambda1,lambda2).}
#' @export
#' 
qr3_rank <- function(X, Y, lambda1, lambda2, err_abs = 10^(-4), err_rel = 10^(-3), maxIter = 200L, rho = 5) {
    .Call(`_HiQR_qr3_rank`, X, Y, lambda1, lambda2, err_abs, err_rel, maxIter, rho)
}

